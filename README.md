# DesignPatterns
# Патерн проектування: Прототип (Prototype)

**Прототип (Prototype)** — це породжувальний патерн проектування, який дозволяє копіювати об'єкти, не вдаючись у подробиці їхньої реалізації та не прив'язуючись до їхніх конкретних класів.

---

##  Проблема, яку він вирішує 

Уявіть, що у вас є складний об'єкт. Вам потрібно створити його точну копію. 

**Що ми робимо зазвичай?**
Створюємо новий порожній об'єкт такого ж класу, а потім по черзі копіюємо значення всіх полів зі старого об'єкта на новий. 

**Але виникають три критичні проблеми:**
1. **Інкапсуляція:** Не кожен об'єкт можна скопіювати ззовні, оскільки частина його стану може бути приватною.
2. **Залежність від класів:** Код, який копіює об'єкти, стає жорстко прив'язаним до їхніх класів. Ви не зможете скопіювати об'єкт, знаючи лише його інтерфейс.
3. **Ресурсоємність:** Ініціалізація складного об'єкта "з нуля" може вимагати багато ресурсів.

---

## Ідея реалізації

Патерн Прототип вирішує цю проблему, **доручаючи створення копій самим об'єктам, що копіюються**. 

Вводиться спільний інтерфейс (або абстрактний клас) з єдиним методом `clone()`. Метод створює новий об'єкт поточного класу і копіює всі поля (навіть приватні, оскільки метод викликається зсередини класу). 

У Python цей патерн реалізується завдяки вбудованому модулю `copy` та функції `deepcopy()`, яка автоматично рекурсивно копіює всі вкладені об'єкти (наприклад, списки розділів), забезпечуючи повну незалежність клону від оригіналу.

---
## Де це доцільно застосовувати в реальних проєктах?

* **Геймдев (Ігрова індустрія)**
Це класичний приклад використання Прототипу. Замість того, щоб створювати кожного NPC (орка, гобліна, космічний корабель) з нуля — обчислюючи його базові характеристики, завантажуючи 3D-моделі та текстури, —  створюється один базовий "Орк-прототип" під час завантаження рівня. Далі він просто клонує його сотні разів, злегка змінюючи координати на карті, зброю або рівень здоров'я.

* **Системи документообігу та генерації звітів**
Якщо ваша програма генерує складні звіти, рахунки або контракти, вигідніше мати базовий об'єкт-шаблон. Цей шаблон вже містить правильно налаштовані колонтитули, стилі шрифтів та структуру таблиць. Для створення нового документа ви просто клонуєте цей шаблон і наповнюєте його новими даними, не витрачаючи ресурси на повторне форматування.

* **Кешування та оптимізація роботи з БД**
Якщо об'єкт формується внаслідок кількох складних `JOIN`-запитів до бази даних (наприклад, агрегований профіль користувача з історією покупок та налаштуваннями), його повторне створення "б'є" по продуктивності. Програма може дістати ці дані один раз, зберегти об'єкт у пам'яті як Прототип, а далі надавати іншим компонентам системи його швидкі клони.



#  Патерн проектування: Міст (Bridge)

**Міст (Bridge)** — це структурний патерн проектування, який розділяє один або кілька класів на дві окремі ієрархії — **Абстракцію** (що ми робимо) та **Реалізацію** (як ми це робимо), дозволяючи змінювати їх незалежно одна від одної.

---

##  Проблема, яку він вирішує

Уявіть, що у нас є геометричні фігури (`Коло`, `Прямокутник`) і ми хочемо додати їм кольори (`Зелений`, `Рожевий`). 

**Що ми робимо зазвичай (проблема розростання класів):**
Ми використовуємо наслідування. У нас з'являються класи `ЗеленеКоло`, `РожевеКоло`, `ЗеленийПрямокутник` тощо. 
Якщо ми додамо ще одну фігуру (наприклад, `Трикутник`) і ще один колір (`Фіолетовий`), кількість класів почне зростати в геометричній прогресії. Код стає громіздким і його важко підтримувати.

---

## Ідея реалізації

Патерн **Міст** пропонує замінити наслідування на **композицію**. 
Ми виділяємо дві окремі ієрархії:
1. **Абстракція (Фігури):** Класи фігур, які керують основною логікою (обчислення площі, периметра).
2. **Реалізація (Кольори):** Класи кольорів.

Абстракція (Фігура) містить у собі посилання на об'єкт Реалізації (Колір). Завдяки цьому ми "перекидаємо міст" між двома ієрархіями. Тепер ми можемо додавати нові фігури або нові кольори абсолютно незалежно одне від одного.

---
## Де це доцільно застосовувати в реальних проєктах?

Патерн "Міст" ідеально підходить, коли система розширюється у двох незалежних напрямках (наприклад, логіка роботи та спосіб її виконання).

* **Математичне моделювання та аналіз даних:** Розділення чисельних методів (Абстракція) від рушіїв обчислення. Наприклад, алгоритм розрахунку дисперсії чи регресії залишається незмінним, а "мостом" підключаються різні бекенди (NumPy, бази даних SQL або власна оптимізована реалізація).
* **Обробка формальних мов та експорт:** Розділення логіки парсингу чи збору статистики (Абстракція) від формату генерації результатів (Реалізація — експорт у JSON, HTML або LaTeX-документ).
* **Кросплатформні UI-бібліотеки:** Тип вікна програми (Абстракція) відокремлений від специфічного графічного API операційної системи (Реалізація — Windows API, macOS Cocoa, Linux Wayland).
* **Інтеграція зовнішніх сервісів (API):** Процес оформлення замовлення чи підписки (Абстракція) підключається через міст до конкретного платіжного провайдера (Реалізація — PayPal, MonoPay).

---

# Патерн проектування: Ланцюжок обов'язків (Chain of Responsibility)

**Ланцюжок обов'язків (Chain of Responsibility)** — це поведінковий патерн проектування, який дозволяє передавати запити послідовно ланцюжком обробників. Кожен наступний обробник вирішує, чи може він обробити запит сам, чи його потрібно передати далі по ланцюгу.

---

## Проблема, яку він вирішує

Уявіть, що у вас є запит (наприклад, скарга клієнта, HTTP-запит або системна помилка), який може бути оброблений різними інстанціями залежно від його складності. 

**Що ми робимо зазвичай:**
Ми пишемо величезний блок перевірок `if-elif-else`, жорстко прив'язуючи логіку відправника запиту до класів-обробників. 
Це призводить до того, що код стає монолітним. Якщо ієрархія обробників зміниться, або з'явиться потреба додати нового (наприклад, між Менеджером і Директором), доведеться переписувати основну бізнес-логіку програми.

---

## Ідея реалізації

Патерн пропонує зв'язати об'єкти-обробники в один ланцюг. 
Кожен обробник має посилання на наступного в ланцюгу (поле `_next`). Отримавши запит, обробник перевіряє свої критерії (наприклад, рівень серйозності проблеми). Якщо він компетентний — він вирішує проблему. Якщо ні — викликає метод обробки у наступного об'єкта.

Таким чином, відправник запиту нічого не знає про те, хто саме виконає його запит, а самі обробники не залежать один від одного.

---

## Де це доцільно застосовувати в реальних проєктах?

Патерн "Ланцюжок обов'язків" ідеально підходить для створення конвеєрів (пайплайнів), де запит має пройти послідовну фільтрацію або знайти відповідного обробника.

* **Пайплайни підготовки даних (Data Preprocessing):** При підготовці датасетів для статистичного аналізу зручно будувати конвеєр обробки. Наприклад: обробник очищення пропущених значень -> обробник пошуку викидів (outliers) -> обробник нормалізації. Кожна ланка виконує свою специфічну дію і передає масив даних наступній.
* **Middleware (Проміжне ПЗ) у веб-фреймворках:** У таких фреймворках, як Django чи FastAPI, кожен HTTP-запит проходить через ланцюг обробників: Перевірка CORS -> Автентифікація -> Логування -> Передача до маршруту. Якщо на етапі автентифікації користувач не проходить перевірку, ланцюг миттєво переривається і повертає помилку.
* **Обробка подій в інтерфейсах (Event Bubbling):** У графічних інтерфейсах (та DOM-дереві веб-сторінок) клік по елементу передається від найглибшого віджета (наприклад, іконки) до батьківського (кнопки), потім до панелі, і так далі, доки якийсь контейнер не перехопить і не обробить цю подію.
